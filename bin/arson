#!/usr/bin/ruby -wW2

# AUR search program. Uses the RPC/JSON interface to query the db. Requires
# rubygems and the JSON gem. And a whole lot more now!

# {{{ Require statements
%w{optparse pp cgi open-uri pathname ftools zlib rubygems json facets/version facets/minitar facets/ansicode}.each do |lib|
	require lib
end

ARSON_VERSION = [0, 8, 11]
# Loui's AUR: "http://aur.louipc.yi.org/"
# He has a bunch of fixes already, useful to test arson against any seriously new changes
#Aur_Domain = "http://aur.louipc.yi.org/"
Aur_Domain = "http://aur.archlinux.org"
Aur_Search = "#{Aur_Domain}/rpc.php?type=search&arg=%s"
Aur_Info = "#{Aur_Domain}/rpc.php?type=info&arg=%s"
Pacman_Local_Cache = "/var/lib/pacman/local"
Pacman_Local_Sync = "/var/lib/pacman/sync/%s"
Pacman_Conf = "/etc/pacman.conf"

$Options = {}
# Parse the options, adding the settings to the $Options hash
def opt_parse(args)
	OptionParser.new do |op|
		op.banner = "arson v#{ARSON_VERSION.join('.')} - The #{colorful('HOT',:red)} AUR search helper!"
		op.separator "Usage: #{colorful('arson',:bold)} [options] -COMMAND KEYWORD1 [KEYWORD2 ...]"

		op.separator "Where -COMMAND is one of:"
		op.on("-D", "--Download", "Download the AUR package specified") do |c|
			puts colorful("Warning: ",:magenta,:bold) + colorful("#{$Options[:command].to_s.capitalize} command already given, ignoring '-S'",:magenta) if $Options[:command]
			$Options[:command] ||= :download
		end
		op.on("-S", "--Search", "Search AUR for a package name") do |s|
			puts colorful("Warning: ",:magenta,:bold) + colorful("#{$Options[:command].to_s.capitalize} command already given, ignoring '-S'",:magenta) if $Options[:command]
			$Options[:command] ||= :search
	end
	op.on("-I", "--Info", "Get information about a package") do |i|
		puts colorful("Warning: Command #{$Options[:command].capitalize} already given, ignoring '-I'",:magenta) if $Options[:command]
		$Options[:command] ||= :info
	end
	op.on("-U", "--Upgrade", "List of foreign packages which have an", "update available for them in AUR") do |u|
		puts colorful("Warning: Command #{$Options[:command].capitalize} already given, ignoring '-U'",:magenta) if $Options[:command]
		$Options[:command] ||= :upgrade
end
op.on("-C", "--Category", "Find a package based on what category it", "is in") do |c|
	puts colorful("Warning: Command #{$Options[:command].capitalize} already given, ignoring '-C'",:magenta) if $Options[:command]
	$Options[:command] ||= :category
end
op.on("-A", "--Abs", "Download a pacman package from ABS") do |c|
	puts colorful("Warning: Command #{$Options[:command].capitalize} already given, ignoring '-A'",:magenta) if $Options[:command]
	$Options[:command] ||= :category
end


#op.separator "\n"
op.separator "Search options"
op.on("--filter [KEYWORD]", "Filter search results by this word.", "It is not included in the original AUR", "search. [Default: #{colorful('Show all results',:magenta)}]") do |filter|
	$Options[:filter] = filter
end

#op.separator "\n"
op.separator "Download options"
op.on("--save-to [PATH]", "Directory for arson to download AUR", "packages [Default: #{colorful('Current directory',:magenta)}]") do |h|
	h = (h[0...1] == "/" ? h : "#{Dir.pwd}/#{h}")
	if File.exists? h
		# JIC someone provides a link
		$Options[:download_dir] = Pathname.new(h).realpath
	else
		puts "Error: #{h} doesn't exist! Please choose a directory that already exists"
		exit 1
	end
  end
  op.on("-k", "--keep", "Keep the .tar.gz after extracting it ", "[Default: #{colorful('Delete',:magenta)}]") do |x|
	  $Options[:no_delete] = x
  end
  op.on("-f", "--force", "Overwrite the package's extraction target", "if it exists. [Default: #{colorful('Don\'t', :magenta)}]") do |force|
	  $Options[:force] = force
  end
  op.on("-r", "--[no-]recursive", "Check the dependency list for other AUR", "packages. [Default: #{colorful('Yes', :magenta)}]") do |recur|
	  $Options[:recursive] = recur
  end
  # Maybe - not sure.
  #  op.on("--makepkg", "Call makepkg to build a package") do |makepkg|
  #	  $Options[:makepkg] = makepkg
  #  end

  #  op.separator "\n"
  op.separator "Upgrade options"
  op.on("--foreign [REPO]", "Set all packages within a repository as", "foreign, to be included in the", "upgrade search. This can be repeated", "multiple times. [Default: #{colorful('None', :magenta)}]") do |repo|
	  unless File.exists? Pacman_Local_Sync % repo
		  puts colorful("Can not find repository #{repo}. Try running `pacman -Sy'?", :red)
	  end
	  $Options[:foreign] = ($Options[:foreigns]||[]) << (Pacman_Local_Sync % repo)
  end


  #  op.separator "\n"
  op.separator "Info options"
  op.on("-l", "--[no-]long", "Use a more tabular display for output") do |long|
	  $Options[:long] = long
		end

		#		op.separator "\n"
		op.separator "Generic options"
		op.on("-v", "--[no-]verbose", "Run verbosely") do |v|
			$Options[:verbose] = v
		end
		op.on("-x", "--no-color", "Supress color output [Default: #{colorful('No',:magenta)}]") do |c|
			$Options[:no_color] = !c
		end
		op.on_tail("-V", "--version", "Display the version number") do |v|
			puts "arson v#{ARSON_VERSION.join('.')}"
			exit 0
		end
		op.on_tail("-h", "--help", "Display this help message") do |h|
			puts op
			exit 0
		end
		op.on_tail("--more-help", "Display even more help") do |mh|
			puts <<EOMHELP
To install all the dependencies (optional or not) of arson, run the following:
	gem install facets json
EOMHELP
			exit 0
		end
	end.parse!(args)

	# Extra option logic
	unless $Options[:command]
		puts colorful("You need to specify a command!",:red)
		opt_parse(["-h"])
		exit 1
	end
	unless $Options[:download_dir]
		$Options[:download_dir] = Pathname.new(Dir.pwd).realpath
	end
	if $Options[:recursive] == nil
		$Options[:recursive] = true
	end
end
# Add ASCII colors to string, using Facet's ANSICode class. effects is a array of symbols that are valid class methods
def colorful(string, *effects)
	unless $Options[:no_color] or ARGV.include? "-c" or ARGV.include? "--no-color"
		colored = " "
		effects.each do |ef|
			colored << "#{ANSICode.send(ef)}"
		end
	colored << string << "#{ANSICode.clear}"
	colored[1..-1]
	else
		string
	end
end
# Opens a given URL and tries parsing the contents as JSON. Returns the resulting hash, no error trapping provided
def json_open(url)
	puts "json_open(#{url})" if $Options[:verbose]
	JSON.parse(open(url).read)
end
# Search the AUR for the array of keywords
def aur_search(keywords)
	puts "Searching for #{keywords.join(' & ')}" if $Options[:verbose]
	list = aur_list(keywords.join(' '))
	count = 0
	puts "Checking keywords for #{list.length} results total" if $Options[:verbose]
	list.each do |values|
		puts "Opening Aur_Info url" if $Options[:verbose]
		info = json_open(Aur_Info % values[1])
		unless info['type'] == 'error'
			info = info['results']
			next if in_pacman_sync?(info['Name'],"community")
			if keywords.any? do |keyword|
				print "#{keyword}, " if $Options[:verbose]
				info['Name'].include? keyword or info['Description'].include? keyword or
				# Check if there is a filter, then check if either Name or Description has filter within.
				($Options[:filter] and (info['Name'].include? filter or info['Description'].include? filter))
			end
			puts " It's a successful match" if $Options[:verbose]
			count += 1
			puts search_style(info['Name'], info['Version'], info['Description'], (info['OutOfDate'] == '1' ? :red : nil))

			end
		else
			puts colorful("Error: #{info['results']} for package ID #{values[0]}",:red)
		end
	end
	puts "Found #{colorful(count.to_s,:magenta)} results"
end
# Download a series of packages from AUR and their AUR dependencies
def aur_download(packages, dependy=false)
	no_pkg = true
	packages.each do |pkg|
		if check_existence(pkg)
			list = aur_list(pkg)
			list.each do |names|
				if names[0] == pkg
					# Download code
					info = json_open(Aur_Info % names[1])['results']
					puts "Download URL: #{colorful(Aur_Domain+info['URLPath'],:green)}" if $Options[:verbose]
					puts "#{colorful('WARNING',:red,:bold)}: You are about to download #{colorful(pkg,:bold)}, which has been flagged #{colorful('out of date',:magenta)}!" if info['OutOfDate'] == '1'
					repo = nil
					pp info if $Options[:verbose]
					FileUtils.chdir($Options[:download_dir]) do |dir|
						begin do
							no_pkg = false
							if repo = is_pacman_pkg? pkg
								puts "Found package #{colorful(pkg,:bold)} in the #{repo} repo. Downloding from ABS..."
								abs_pull pkg, repo
							else
								puts "Found #{dependy ? 'dependency' : 'package'} #{colorful(pkg,:bold)}! Downloading it now..."
								open("#{Aur_Domain}/#{info['URLPath']}") do |tar|
									# Write the stream to a file, b is JIC
									File.open("#{dir}/#{pkg}.tar.gz", "wb") do |file|
										puts colorful("Downloading #{pkg}",:blue) if $Options[:verbose]
										file.write(tar.read)
									end
								end
							end
						rescue OpenURI::HTTPError => e
							if e.message.include? "404"
								begin
									no_pkg = false
									puts "404 Error when downloading #{pkg}, attempting to use the pattern to download" if $Options[:verbose]
									open("#{Aur_Domain}/packages/#{pkg}/#{pkg}.tar.gz") do |tar|
										# Write the stream to a file, b is JIC
										File.open("#{dir}/#{pkg}.tar.gz", "wb") do |file|
											puts colorful("Downloading #{pkg}",:blue) if $Options[:verbose]
											file.write(tar.read)
										end
									end
								rescue OpenURI::HTTPError => e
									puts colorful("Error downloading #{pkg}: #{e.message}",:red)
									no_pkg = false # Eh, you never know...
									exit 1
								end
							else
								puts colorful("Error downloading #{pkg}: #{e.message}",:red)
								no_pkg = false # Eh, you never know...
#								exit 1
							end
						end
						puts colorful("Extracting #{pkg}.tar.gz",:blue) if $Options[:verbose]
						# Extract the archive
						tgz = Zlib::GzipReader.new(File.open("#{pkg}.tar.gz", 'rb'))
						# Extract pkg.tar.gz to `pwd`, instead of `pwd`/pkg
						Archive::Tar::Minitar.unpack(tgz, Dir.pwd)

						# Checking if pkg.tar.gz is marked to be deleted
						if $Options[:no_delete]
							FileUtils.mv "#{pkg}.tar.gz", pkg
						else
							FileUtils.rm "#{pkg}.tar.gz" if File.exists? "#{pkg}.tar.gz"
						end

						if $Options[:recursive]
							dependencies = File.readlines("#{pkg}/PKGBUILD").grep(/^(?:make)*depends/).map{|l| l.match(/.*=\((.*)\)$/)[1].gsub("'", '').split(' ')}.flatten.uniq.sort
							p dependencies if $Options[:verbose]
							within = []
							$Options[:repos].each do |repo|
								dependencies.each do |depend|
									if in_pacman_sync? depend, repo
										within << depend unless within.include? depend
									end
								end
							end
							aurds = dependencies - within
							p aurds if $Options[:verbose]
							aurds.each do |depend|
								# Recursive!!!!
								aur_download(depend, true) # This is a dependency download
							end
						end
						if $Options[:makepkg]
							system("makepkg -s #{'--nocolor' if $Options[:no_color]}")
						end
					end

				end
			end
			if no_pkg and !dependy
				puts colorful("Error: No package named '#{pkg}' found",:red)
				exit 1
			end
		else
			puts colorful("Error: #{$Options[:download_dir]}/#{pkg} already exists. Pass -f to overwrite it.", :red)
			exit 1
		end # if check_existence(pkg)
	end # packages.each do |pkg|
end
# Return an array containing an array of [pkg name, id]
def aur_list(name)
	puts Aur_Search % CGI::escape(name) if $Options[:verbose]
	json = json_open(Aur_Search % CGI::escape(name))
	list = []

	if json['type'] == 'error'
		puts colorful("Error: #{json['results']}",:red)
		exit 1
	end
	json['results'].each do |aurp|
		list << [aurp["Name"], aurp['ID']]
	end
	list.sort
end
# Display info about a package
def aur_info(names)
	names.each do |name|
		puts "Getting package info for #{colorful(name,:red)}" if $Options[:verbose]
		aur_list(name).each do |pkg|
			if pkg[0] == name
				json = json_open(Aur_Info % pkg[1])['results']
				if $Options[:long]
					puts json.keys.map{|key| " #{key.rjust(json.keys.sort_by {|key2| key2.length }.last.length)} : #{json[key]}" }
				else
					not_ood = (json['OutOfDate'] == '0' ? 'is not' : colorful('is',:red))
					# Not installed
					inst_upg_info = "is #{colorful('not installed',:green,:bold)} on your system" if pacman_cache_check(json['Name'],json['Version']) == 'N'
					# Installed
					inst_upg_info = "is #{colorful('installed',:green)} on your system" if pacman_cache_check(json['Name'],json['Version']) == 'I'
					# Upgradable
					inst_upg_info = "has an #{colorful('upgrade',:blue)} available" if pacman_cache_check(json['Name'],json['Version']) == 'U'

					puts <<EOINFO
#{colorful(json['Name'],:blue,:bold)} (#{colorful(json['Version'],:bold)}) #{json['Description']}
#{json['URL']}
Released under the '#{colorful(json['License'],:green)}' license. Received #{colorful(json['NumVotes'],:green)} votes. It #{not_ood} out of date.
#{json['Name']} #{inst_upg_info}

EOINFO
				end # if $Options[:info]
			end
		end
	end
end
# Returns true or false if pacman has a chached copy of a package at the given version
def pacman_cache_check(name, version, cached = Pacman_Local_Cache)
	puts "Checking installation status of #{name}, v#{version}" if $Options[:verbose]
	if File.exists? "#{cached}/#{name}-#{version}"
		return 'I'
	else
		Dir.chdir(cached) do
			installed = Dir["#{name}-*"].first
			if installed
				iv = VersionNumber.new(installed[name.length+1..-1])
				pccv = VersionNumber.new(version)
				if iv > pccv
					return 'I'
				elsif pccv > iv
					return 'U'
				end
			else
				return 'N'
			end
		end
	end
end
# Check if pacman's db has information about a package being in a repository, regardless of version
def in_pacman_sync?(name, syncd)
	syncd = Pacman_Local_Sync % syncd
	return true if Dir["#{syncd}/#{name}-*"].first
end
# Using pacman's list of foreign packages, check if any have updates in AUR
def pacman_check_aur_updates
	puts "Checking if any foreign packages have updates available in AUR" if $Options[:verbose]
	found_toggle = false


	`pacman -Qm`.each_line do |line|
		name, version = line.chomp.split
		aur = json_open(Aur_Info % name)['results']
		if aur.kind_of?(Hash) and aur['Version'] != version
			found_toggle = true
			instver = VersionNumber.new(version)
			aurver = VersionNumber.new(aur['Version'])
			puts "#{colorful(name,:bold)} has an update available: #{colorful(version,:red)} -> #{colorful(aur['Version'],:green)}" if aurver > instver
		end
	end

	for repo in $Options[:foreign]
		puts "Searching #{repo} for updates in AUR..."
		Dir["#{Pacman_Local_Sync % repo}/*"].each do |pkg|
			desc = File.read(get_package_desc(pkg))
			cache = {:v => desc[/^%VERSION%\n(.*)/, 1], :n => desc[/^%NAME%\n(.*)/, 1]}
			aur = json_open(Aur_Info % cache[:n])
			if aur['type'] == 'error'
				next
			end
			found_toggle = true
			instver = VersionNumber.new(cache[:v])
			aurver = VersionNumber.new(aur['Version'])
			puts "#{colorful(name,:bold)} has an update available: #{colorful(version,:red)} -> #{colorful(aur['Version'],:green)}" if aurver > instver

		end
	end if $Options[:foreign]
	unless found_toggle
		puts "All foreign packages are up to date."
	end
end
# Checks if a package has already been downloaded
def check_existence(pkg)
	puts "Checking existence of #{colorful(pkg,:blue)}/" if $Options[:verbose]
	return true if $Options[:force]
	if File.exists?(File.join($Options[:download_dir], pkg))
		return false
	else
		return true
	end
end
# Pulls a package from ABS
def abs_pull(repo, pkg)
	if File.exists? "/usr/bin/rsync"
		Dir.chdir($Options[:download_dir])
		`/usr/bin/rsync -mrt --no-motd --delete-after rsync.archlinux.org::abs/i686/#{repo}/#{pkg} .`
	end
end
# Gets the categories or packages underneath a category
def pacnet_cats(category)
	if category
		pkgs = json_open("http://pacnet.karbownicki.com/api/json/category/#{category}")
		p pkgs.class, pkgs.first.class if $Options[:verbose]
	#	pkgs.sort! {|pkga, pkgb| pkga['name'] <=> pkgb['name'] }
		pkgs.each do |pkg|
			puts search_style(pkg['name'], pkg['version'], pkg['description'])
		end
		puts "Found #{colorful(pkgs.size.to_s ,:magenta)} results"
		pp pkgs if $Options[:verbose]
	else
		puts open("http://pacnet.karbownicki.com/api/text/categories").read
	end
end
# Does the styling of a package (whether AUR or Pacman), ready for output in the search results
def search_style(name, version, description, highlight=nil)
	versionc = colorful(version,:bold)
	versionc = colorful(version,:bold,highlight) if highlight
	install_char = pacman_cache_check(name, version)
	install_stat = colorful(install_char, :underline, :blue)
	install_stat = colorful(install_char, :cyan) if install_char == 'I'
	install_stat = colorful(install_char, :underline, :red) if install_char == 'U'
	package = colorful("#{get_package_repo name}/#{name}",:bold,:blue)

	# TODO: repo detection code hasn't be written yet, add a repo status
	# to the results once it's done
	"[#{install_stat}] #{package} (#{versionc}): #{description}"
end
# Returns the repo a package is in if it's in pacman's cache, otherwise nil
def is_pacman_pkg?(package)
	idx = $Options[:repos].map {|repo| in_pacman_sync? package, repo }.index(true)
	idx ? $Options[:repos][idx] : nil # Since array[nil] doesn't work
end
# A slight wrapper around is_pacman_pkg?, changes default nil for 'aur'
def get_package_repo(package)
	is_pacman_pkg?(package) || 'aur'
end
# Returns the next line in a Pacman pkg description file
def next_line(pkg, percent)
	desc = File.read("#{pkg}/desc")
	cache = {:v => desc[/^%VERSION%\n(.*)/, 1], :n => desc[/^%NAME%\n(.*)/, 1]}
end
# Returns the file name of the given pkg's desc file, used by Pacman
def get_package_desc(pkg)
	files = Dir["#{Pacman_Local_Sync % repo}/#{pkg}-*"]
	if files.length == 1
		"#{files[0]}/desc"
	else
		packages = files.map {|file| file.split('/').last.split('-')[0...-2].join('-') == pkg }
		if packages.include? pkg
			"#{files[packages.index(pkg)]}/desc"
		end
	end
end
# Return an array of packages with a unified api, via the use of a Struct
def pkg_list(name)
	puts Aur_Search % CGI::escape(name) if $Options[:verbose]
	puts Pacnet_Search % CGI::escape(name) if $Options[:verbose]

	# --- AUR JSON RPC
	aur_json = json_open(Aur_Search % CGI::escape(name))
	pacnet_json = json_open(Pacnet_Search % CGI::escape(name))

	list = []

	# pkg = Package.new(name, version, description, url, license,
	# 	path, id, votes, ood)

	unless aur_json['type'] == 'error'
		aur_json['results'].each do |aurp|
		unless is_pacman_pkg? aurp['Name']
			puts "Opening Aur_Info url" if $Options[:verbose]
			info = json_open(Aur_Info % values[1])
			unless info['type'] == 'error'
				info = info['results']
				next if in_pacman_sync?(info['Name'],"community")
				if keywords.any? do |keyword|
					print "#{keyword}, " if $Options[:verbose]
					info['Name'].include? keyword or info['Description'].include? keyword or
					# Check if there is a filter, then check if either Name or Description has filter within.
					($Options[:filter] and (info['Name'].include? filter or info['Description'].include? filter))
				end
				puts " It's a successful match" if $Options[:verbose]
				# pkg = Package.new(name, version, description, url, license,
				# 	path, id, votes, ood, type)
				list << Package.new(info['Name'], info['Version'], info['Description'], info['URL'], info['License'],
						    info['URLPath'], info['ID'], info['NumVotes'], (info['OutOfDate'] == '1'), 'aur')
				end
			else
				puts colorful("Error: #{info['results']} for package ID #{values[0]}",:red)
			end
		else
			# pkg = Package.new(name, version, description, url, license,
			# 	path, id, votes, ood, type)
			# Pacman package - this code is much simpler due to helper functions! :D
			list << Package.new(percent_value(pkg, :name), percent_value(pkg, :version), percent_value(pkg, :description), percent_value(pkg, :url), percent_value(pkg, :license), get_package_desc(pkg), percent_value(pkg, :csize), percent_value(pkg, :isize), false, 'pac')
		end
		end
	else
		puts colorful("Error: #{aur_json['results']}",:red) if $Options[:verbose]
	end

	if pacnet_json.class == Array # pacnet returns a hash on empty result set
		pacnet_json.each do |pacn|
			list << Package.new(percent_value(pacn['name'], :name), percent_value(pacn['name'], :version), percent_value(pacn['name'], :description), percent_value(pacn['name'], :url), percent_value(pacn['name'], :license), get_package_desc(pacn['name']), percent_value(pacn['name'], :csize), percent_value(pacn['name'], :isize), false, 'pac')
		end
	end

	# Alphabetical search
	list.sort {|pkga, pkgb| pkga.name <=> pkgb.name}
end

if $0 == __FILE__
	trap(:INT) { exit 1 } # Exit gracefully...kinda :)

	begin # opt_parse call
		opt_parse(ARGV)
	rescue OptionParser::InvalidOption => e
		puts colorful("#{e.to_s.capitalize}. Please use only the following:",:red)
		opt_parse(["-h"])
	rescue OptionParser::AmbiguousOption => e
		puts colorful("#{e.to_s.capitalize}. Please make sure that you have only one short argument, regardless of case.", :red)
		opt_parse(['-h'])
	end

	if ARGV.size < 1 and ![:upgrade, :category].include? $Options[:command]
		puts "#{colorful('No keywords found!',:red)} Try using only alphanumeric characters for your keywords."
		opt_parse(["-h"]) # Force the help message to be displayed
	end

	pp ARGV if $Options[:verbose]
	pp $Options if $Options[:verbose]

	# Set $Options[:repos] to an array of repos enabled in /etc/pacman.conf
	$Options[:repos] = File.read(Pacman_Conf).scan(/^\[(.*)\]/).flatten
	# Remove the first repo name (which really isn't a repo anyways)
	# This is '[options]'
	$Options[:repos].reverse! ; $Options[:repos].pop ; $Options[:repos].reverse!

	if $Options[:command] == :search
		aur_search(ARGV)
	elsif $Options[:command] == :download
		puts "Downloading package#{ARGV.length > 1 ? 's' : ''} to #{colorful($Options[:download_dir],:bold,:magenta)}"
		aur_download(ARGV)
	elsif $Options[:command] == :info
		aur_info(ARGV)
	elsif $Options[:command] == :upgrade
		pacman_check_aur_updates
	elsif $Options[:command] == :category
		pacnet_cats(ARGV[0])
	end
end

